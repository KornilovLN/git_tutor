#--------------------------------------------------------------------------------------
#--- Книга: Git для профессионального программиста и другие источники
#--------------------------------------------------------------------------------------

#--- git setup on Mint ----------------------------------------------------------------
$ sudo apt update
$ sudo apt install git
$ git --version
> git version 2.25.1

#--- Первая настройка Git: Внести инфо о себе в глобальный файл config ----------------
$ git config --global user.email "ln.KornilovStar@gmail.com"
$ git config --global user.name "KornilovLN"

//--- всегда можно посмотреть config файл
$ git config -l
> user.email=ln.KornilovStar@gmail.com
> user.name=KornilovLN
> core.repositoryformatversion=0
> core.filemode=true
> core.bare=false
> core.logallrefupdates=true

#-------------------------------------------------------------------------------------
#--- Справка по командам
#-------------------------------------------------------------------------------------
$ git help <команда>
$ git <команда> --help
$ man git-<команда>

#-------------------------------------------------------------------------------------
#--- local repository work with git: можно загрузить из github командой clone шаблон -
#-------------------------------------------------------------------------------------
#--- например так:
$ PATH/git_test$ git clone https://github.com/KornilovLN/git_tutor.git
> Клонирование в «git_tutor»...
> remote: Enumerating objects: 3, done.
> remote: Counting objects: 100% (3/3), done.
> remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
> Распаковка объектов: 100% (3/3), 622 байта | 622.00 КиБ/с, готово.

#--- получен ранее имеющийся на GITHUB проект в папке git_tutor
$ ll
> итого 16
> drwxrwxr-x 3 leon leon 4096 июл 31 20:46 ./
> drwxrwxr-x 3 leon leon 4096 июл 31 20:46 ../
> drwxrwxr-x 8 leon leon 4096 июл 31 20:46 .git/
> -rw-rw-r-- 1 leon leon   38 июл 31 20:46 README.md

#--- посмотрим status (кстати: придет текущая ветка main)
$ git status
> Текущая ветка: main
> Эта ветка соответствует «origin/main».
> нечего коммитить, нет изменений в рабочем каталоге

#-------------------------------------------------------------------------------------
#--- Создать файл .gitignore 
#-------------------------------------------------------------------------------------
# комментарий – это игнорируется
*.a         # пропускать файлы, заканчивающиеся на .a
!lib.a      # но отслеживать файлы lib.a, несмотря на пропуск файлов на .a
/TODO       # игнорировать только корневой файл TODO, а не файлы вида subdir/TODO
build/      # игнорировать все файлы в папке build/
doc/*.txt   # игнорировать doc/notes.txt, но не doc/server/arch.txt 

#-------------------------------------------------------------------------------------
#--- или создать локальный репозиторий в нужном месте 
#-------------------------------------------------------------------------------------
$ mkdir prj_0
$ cd prj_0
$ git init .
> Инициализирован пустой репозиторий Git в /home/leon/dev/ard/prj_0/.git/

#--- смотрим, что создано 
$ ls -la
> итого 12
> drwxrwxr-x 3 leon leon 4096 июл 22 21:55 .
> drwxrwxr-x 3 leon leon 4096 июл 22 21:55 ..
> drwxrwxr-x 7 leon leon 4096 июл 22 21:55 .git

$ git status
> Текущая ветка: master (в отличие от метода клонирования, ветка будет названа master)
> Еще нет коммитов
> нечего коммитить (создайте/скопируйте файлы, затем запустите
> «git add», чтобы отслеживать их)

#--- добавим файл в проект-папку ZB: txt
$ git status
> Текущая ветка: master
> Еще нет коммитов
> Неотслеживаемые файлы:
>   (используйте «git add <файл>...», чтобы добавить в то, что будет включено в коммит)
>	txt
> индекс пуст, но есть неотслеживаемые файлы
> (используйте «git add», чтобы проиндексировать их)

$ git add .
$ git status
> Текущая ветка: master
> Еще нет коммитов
> Изменения, которые будут включены в коммит:
>   (используйте «git rm --cached <файл>...», чтобы убрать из индекса)
> 	новый файл:    txt

#--- первый commit
$ git commit -m "Initial commit prj_0 v0.1"
> [master (корневой коммит) 88aaa76] Initial commit prj_0 v0.1
>  1 file changed, 7 insertions(+)
>  create mode 100644 txt

$ git status
> Текущая ветка: master
> нечего коммитить, нет изменений в рабочем каталоге

//--- посмотреть лог последнего коммита
$ git log -1
> commit 88aaa760b0843539759552a248de6f2a5ca2961f (HEAD -> master)
> Author: KornilovLN <ln.starmark@ekatra.io>
> Date:   Sat Jul 22 22:18:49 2023 +0300
>    Initial commit prj_0 v0.1

//--- как вернуть предидущее состояние модифицированному файлу txt
$ git checkout -- txt

//--- разница в измененом файле относ. последнего коммита
$ git diff --staged



//=======================================================================================
//--- Дополнение ------------------------------------------------------------------------

Установка Git

GitHub предоставляет оконное приложение с графическим интерфейсом 
для выполнения основных операций с репозиторием, 
и консольную версию Git с автоматическими обновлениями 
для расширенных сценариев работы.

GitHub Desktop
desktop.github.com

Дистрибутивы Git для систем Linux и POSIX 
доступны на официальном сайте Git SCM.

Git для всех платформ
git-scm.com

#--- Первоначальная настройка

Настройка информации о пользователе 
для всех локальных репозиториев

$ git config --global user.name "[имя]"

Устанавливает имя, которое будет отображаться в поле автора 
у выполняемых вами коммитов

$ git config --global user.email "[адрес электронной почты]"

Устанавливает адрес электронной почты, 
который будет отображаться в информации о 
выполняемых вами коммитах

#---Создание репозитория
Создание нового репозитория или получение его 
по существующему URL-адресу

$ git init [название проекта]

Создаёт новый локальный репозиторий с заданным именем

$ git clone [url-адрес]

Скачивает репозиторий вместе со всей его историей изменений

#--- Внесение изменений

Просмотр изменений и создание коммитов (фиксация изменений)

$ git status

Перечисляет все новые или изменённые файлы, 
которые нуждаются в фиксации

$ git diff

Показывает различия по внесённым изменениям 
в ещё не проиндексированных файлах

$ git add [файл]

Индексирует указанный файл для последующего коммита

$ git diff --staged

Показывает различия между проиндексированной и 
последней зафиксированной версиями файлов

$ git reset [файл]

Отменяет индексацию указанного файла,
при этом сохраняет его содержимое

$ git commit -m "[сообщение с описанием]"

Фиксирует проиндексированные изменения и сохраняет их в историю версий

#--- Коллективная работа

Именованные серии коммитов и соединение результатов работы

$ git branch

Список именованных веток коммитов с указанием выбранной ветки

$ git branch [имя ветки]

Создаёт новую ветку

$ git switch -c [имя ветки]

Переключается на выбранную ветку и обновляет 
рабочую директорию до её состояния

$ git merge [имя ветки]

Вносит изменения указанной ветки в текущую ветку

$ git branch -d [имя ветки]

Удаляет выбранную ветку

#--- Операции с файлами

Перемещение и удаление версий файлов репозитория

$ git rm [файл]

Удаляет конкретный файл из рабочей директории и 
индексирует его удаление

$ git rm --cached [файл]

Убирает конкретный файл из контроля версий, 
но физически оставляет его на своём месте

$ git mv [оригинальный файл] [новое имя]

Перемещает и переименовывает указанный файл, 
сразу индексируя его для последующего коммита

Игнорирование некоторых файлов
Исключение временных и вторичных файлов и директорий

*.log
build/
temp-*
Git будет игнорировать файлы и директории, 
перечисленные в файле .gitignore с помощью wildcard синтаксиса

$ git ls-files --others --ignored --exclude-standard

Список всех игнорируемых файлов в текущем проекте

#--- Сохранение фрагментов

Сохранение и восстановление незавершённых изменений

$ git stash

Временно сохраняет все незафиксированные изменения 
отслеживаемых файлов

$ git stash pop

Восстанавливает состояние ранее сохранённых версий файлов

$ git stash list

Выводит список всех временных сохранений

$ git stash drop

Сбрасывает последние временно сохранённыe изменения

#--- Просмотр истории

Просмотр и изучение истории изменений файлов проекта

$ git log

История коммитов для текущей ветки

$ git log --follow [файл]

История изменений конкретного файла, включая его переименование

$ git diff [первая ветка]...[вторая ветка]

Показывает разницу между содержанием коммитов двух веток

$ git show [коммит]

Выводит информацию и показывает изменения в выбранном коммите

#--- Откат коммитов

Удаление ошибок и корректировка созданной истории

$ git reset [коммит]

Отменяет все коммиты после заданного, 
оставляя все изменения в рабочей директории

$ git reset --hard [коммит]

Сбрасывает всю историю вместе с состоянием рабочей директории 
до указанного коммита.

#--- Синхронизация с удалённым репозиторием

Регистрация удалённого репозитория и обмен изменениями

$ git fetch [удалённый репозиторий]

Скачивает всю историю из удалённого репозитория

$ git merge [удалённый репозиторий]/[ветка]

Вносит изменения из ветки удалённого репозитория 
в текущую ветку локального репозитория

$ git push [удалённый репозиторий] [ветка]

Загружает все изменения локальной ветки в удалённый репозиторий

$ git pull

Загружает историю из удалённого репозитория и 
объединяет её с локальной. 
pull = fetch + merge

//=====================================================================================
//--- Дополнение ----------------------------------------------------------------------

Чтобы проверить предыдущие коммиты и вернуться на шаг назад.
Вот пошаговая инструкция:


1 Проверьте историю коммитов:

git log --oneline

Это покажет список коммитов с их хэшами и сообщениями.



2 Найдите коммит, к которому хотите вернуться.
  Чтобы временно вернуться к предыдущему состоянию без создания нового коммита:

git checkout <хэш_коммита>



3 Замените <хэш_коммита> на хэш нужного коммита.
  Если вы хотите создать новую ветку с этого состояния:

git checkout -b <имя_новой_ветки> <хэш_коммита>



4 Если вы хотите полностью откатить изменения и создать новый коммит:

git revert <хэш_коммита>


Это создаст новый коммит, отменяющий изменения указанного коммита.


5 Если вы хотите просто отменить изменения в рабочей директории:

git reset --hard <хэш_коммита>



Будьте осторожны с этой командой, так как она безвозвратно удалит все изменения после указанного коммита.
Если вы не использовали Git, но у вас есть резервные копии файлов,
просто замените текущие файлы предыдущими версиями.

После возврата к предыдущему состоянию, проверьте работоспособность кода.
Если проблемы persist, мы можем пошагово проанализировать код и найти источник проблемы.



Итак: Надо вернуться на шаг назад:

git log --oneline

d57517c (HEAD -> br_all_links, origin/br_all_links, origin/br_add_templates, br_add_templates) Removed all templates into templates folder
ab71f15 Moving templates into folder templates
...
...


Теперь у нас есть информация о коммитах.
Чтобы вернуться на шаг назад, к коммиту ab71f15, выполните следующие шаги:

1 Сначала, давайте убедимся, что у вас нет несохраненных изменений:

git status


2 Если есть несохраненные изменения, которые вы хотите сохранить, сделайте коммит или стэш.

git add .
git commit -m "Сохранение текущего состояния перед откатом"


3 Теперь вернемся к предыдущему коммиту:

git checkout ab71f15

Вы теперь находитесь в состоянии "detached HEAD".


4 Если вы хотите продолжить работу с этого места, создайте новую ветку:

git checkout -b restore_previous_state



Теперь вы находитесь в состоянии кода, которое было до перемещения шаблонов в папку templates.
Проверьте, работает ли код теперь корректно.
Если вы хотите полностью откатить последний коммит и продолжить работу в текущей ветке:

Выполните:

git reset --hard ab71f15


Это переместит указатель текущей ветки на предыдущий коммит.
Если вы уже отправили изменения в удаленный репозиторий, вам может потребоваться выполнить форс-пуш:

git push --force origin br_all_links

Будьте осторожны с этой командой, особенно если над проектом работает несколько человек.



После выполнения этих шагов, ваш код должен вернуться в состояние до последних изменений.
Проверьте, решило ли это проблему.
Если нет, мы можем более детально разобрать код и найти источник проблемы.



Таким образом:

Ваше текущее состояние сохранено в ветке br_all_links, откуда ушли.
Вы работаете с предыдущим состоянием в новой ветке restore_previous_state
Это позволит вам безопасно экспериментировать с кодом в предыдущем состоянии,
 не теряя при этом последних изменений.
Если вы решите, что хотите вернуться к последнему сохраненному состоянию,
 вы всегда сможете переключиться обратно на ветку br_all_links.

Когда вы закончите работу и решите, какое состояние кода вы хотите оставить,
 вы сможете либо продолжить работу в новой ветке,
 либо применить изменения к основной ветке через merge или cherry-pick.



Если меня устроит эта ветка, то я смогу удалить ту, с которой ушел?

Если вас устроит новая ветка (restore_previous_state),
 вы сможете удалить ветку, с которой ушли (br_all_links).

Вот как это сделать:

1 Убедитесь, что вы находитесь на ветке restore_previous_state:

git checkout restore_previous_state



2 Если вы уверены, что хотите удалить ветку br_all_links, выполните:

git branch -d br_all_links



3 Если Git выдаст предупреждение о том, что ветка не полностью слита,
 и вы все равно уверены, что хотите ее удалить, используйте:

git branch -D br_all_links



4 Если ветка br_all_links была отправлена в удаленный репозиторий, вы также можете удалить ее оттуда:

git push origin --delete br_all_links



5 Если вы хотите переименовать текущую ветку restore_previous_state в br_all_links, выполните:

git branch -m br_all_links



6 Если вы отправляли изменения в удаленный репозиторий, обновите его:

git push origin -u br_all_links



Помните, что удаление ветки - это необратимая операция.
 Убедитесь, что вы действительно хотите удалить ветку
 и что все нужные изменения сохранены в текущей ветке или в других ветках.

Также, если вы работаете в команде, убедитесь, что удаление ветки не повлияет на работу других разработчиков.
 Всегда лучше сначала обсудить такие изменения с командой.



В большинстве случаев перезагружать VSCode не требуется.
 VSCode достаточно хорошо интегрирован с Git
 и обычно автоматически обновляет информацию о ветках и состоянии репозитория.
 Однако, есть несколько моментов, которые стоит учесть:

Обновление Git-панели:

Иногда может потребоваться вручную обновить Git-панель в VSCode.
 Для этого нажмите на значок обновления в панели Git
 или используйте сочетание клавиш Ctrl+Shift+G (или Cmd+Shift+G на Mac),
 чтобы открыть панель Git, а затем нажмите на значок обновления.

Переключение между файлами:

Если у вас открыты файлы, которые были изменены при переключении веток,
 VSCode может предложить перезагрузить их.
 Согласитесь с этим предложением.

Терминал:

Если вы использовали встроенный терминал VSCode для выполнения Git-команд,
 убедитесь, что вы находитесь в правильной ветке,
 выполнив git branch в терминале.

Статус бар:

Проверьте статус бар в нижней части VSCode.
 Там должно отображаться название текущей ветки.
 Если оно не обновилось, попробуйте кликнуть на него.

Полная перезагрузка:

Если вы заметили, что VSCode не отображает актуальное состояние репозитория
 или возникают другие проблемы, полная перезагрузка VSCode может помочь.
 Закройте VSCode и откройте его снова.

Очистка кэша:

В редких случаях может потребоваться очистить кэш VSCode.
 Это можно сделать, закрыв VSCode, удалив папку .vscode в вашем проекте (если она есть) и снова открыв VSCode.

В большинстве случаев VSCode автоматически распознает
 изменения в Git-репозитории без необходимости перезагрузки.
 Но если вы заметили, что что-то отображается некорректно,
 не стесняйтесь перезагрузить VSCode - это быстрый и безопасный способ убедиться, что все синхронизировано.








